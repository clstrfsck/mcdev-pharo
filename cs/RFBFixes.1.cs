'From Pharo1.4a of ''16 June 2011'' [Latest update: #14369] on 10 March 2012 at 7:36:08 pm'!!RFBSession methodsFor: 'message dispatching' stamp: 'mps 3/1/2012 13:10'!rfbNormal	"Receive and process the next normal protocol message."	| type |	socket isConnected ifTrue: [		type := (socket receiveData: (RFBMessage new: 1)) byteAt: 1.		(type < 0) | (type >= MessageTypes size)			ifTrue:				[self log: 'illegal message type ' , type printString , ' received'.				 self abort].		self perform: (MessageTypes at: 1 + type).	].! !!RFBSocket methodsFor: 'receiving' stamp: 'mps 3/3/2012 11:14'!receiveData: stringOrByteArray startingAt: initialIndex	"Receive an incoming message."	| index count |	index := initialIndex.	[index <= stringOrByteArray size] whileTrue: [		count := self receiveDataInto: stringOrByteArray startingAt: index.		count = 0 ifTrue: [			InvalidSocketStatusException signal: 'Socket is closed!!'		].		index := index + count	].	^stringOrByteArray! !!RFBSocket methodsFor: 'sending' stamp: 'mps 3/1/2012 13:20'!waitForSendDoneFor: timeout	"This is a (dual) bug-fix implementation only.  Broken VMs (like the Windoze one) confuse the read and write Semaphores (bug #1), and the new Socket implementation fails utterly to deal properly with the situation (bug #2)."	| remainingTime drainDelay sendDone |	sendDone := false.	remainingTime := timeout * 1000.	drainDelay := Delay forMilliseconds: 5.	"Time to send 4 MTUs on a 10Mbps network."	"Avoid waiting on the writeSemaphore, otherwise the server read loop goes catatonic."	[self isConnected			and: [(sendDone := self primSocketSendDone: socketHandle) not			and: [remainingTime > 0]]]		whileTrue:			[drainDelay wait.			 remainingTime := remainingTime - 6].	^sendDone! !!RFBSocket class methodsFor: 'instance creation' stamp: 'mps 3/1/2012 12:43'!acceptFrom: aSocket	"Answer a new RFBSocket for the connection just accepted on aSocket."	^RFBSocketInstances add: (super acceptFrom: aSocket)! !